#!/bin/sh

# Helper script in POSIX shell to self update appimages in place

# depends on appimageupdatetool which can either be installed by the user
# or be bundled in the application

# if you want to bundle appimageupdateool check this fork instead since it is
# a lot smaller:https://github.com/pkgforge-dev/AppImageUpdate-Enhanced-Edition

# simple make sure you have your AppRun call this script before starting the
# main application, that is all that's needed.

# you can set the var UPDATE_MSG to change the displayed update message

# this script should be ran in the background as it can take a few
# seconds to check for update

set -e

CACHEDIR="${XDG_CACHE_HOME:-$HOME/.cache}"/auto-updates-policy
LOCKFILEPATH="$CACHEDIR"/"$APPNAME"-update-setting
APPNAME=${APPIMAGE##*/}
WELCOME_MSG=${WELCOME_MSG:-Do you want $APPNAME to check for updates?}
UPDATE_MSG="${UPDATE_MSG:-A new version of $APPNAME is available. Do you wish to update?}"
POST_UPDATE="$APPNAME updated suscesfully!"
DO_NOT_ASK="Do you wish to not see this message again?"

# make sure we can update the thing
_sanity_check() {
	if [ -z "$APPIMAGE" ]; then
		return 1
	elif ! command -v appimageupdatetool; then
		>&2 echo "Install appimageupdatetool in PATH to get self updates"
		return 1
	elif [ ! -w "$APPIMAGE" ]; then
		>&2 echo "We cannot to overwrite $APPIMAGE due to lack of permissions"
		>&2 echo "This usually happens when the appimage is placed in /usr/bin"
		>&2 echo "or similar locations that need elevated rights to replace"
		return 1
	elif ! command -v yad \
	  && ! command -v zenity \
	  && ! command -v kdialog; then
		return 1
	fi
}

_display_message() {
	if command -v kdialog 1>/dev/null; then
		kdialog --yesno "$*" || return 1
	elif command -v yad 1>/dev/null; then
		yad --text="$*" || return 1
	elif command -v zenity 1>/dev/null; then
		zenity --question --text "$*" || return 1
	fi
}

_check_update() {
	set +e
	appimageupdatetool -j "$APPIMAGE"
	status=$?
	set -e
	# exit code >1 likely indicates the app was not correctly packaged
	case "$status" in
		0) >&2 echo " $APPNAME is up to date"; return 1;;
		1) >&2 echo " $APPNAME update is available"; return 0;;
		*) >&2 echo " $APPNAME update check failed"; exit 0;;
	esac
}

_update() {
	appimageupdatetool -Or "$APPIMAGE"
}

_create_updates_setting() {
	if [ ! -f "$LOCKFILEPATH" ]; then
		mkdir -p "$CACHEDIR"
		echo "2" > "$LOCKFILEPATH"
	fi
}

_enable_update_checking() {
	echo "1" > "$LOCKFILEPATH"
}

_disable_update_checking() {
	echo "0" > "$LOCKFILEPATH"
}

# if check fails exit without error so that the app can still launch
_sanity_check 1>/dev/null || exit 0

# Make the lockfile if it does not exist
_create_updates_setting

# Now read the file and determine what to do
read -r STATUS < "$LOCKFILEPATH"
if [ "$STATUS" = 2 ]; then
	if _display_message "$WELCOME_MSG"; then
		_enable_update_checking
	else
		_disable_update_checking
	fi
elif [ "$STATUS" = 0 ]; then
	exit 0
elif [ "$STATUS" = 1 ]; then
	if _check_update; then
		if _display_message "$UPDATE_MSG"; then
			_update
			if command -v notify-send 1>/dev/null; then
				notify-send "$POST_UPDATE"
			fi
		elif _display_message "$DO_NOT_ASK"; then
			_disable_update_checking
		fi
	fi
fi
